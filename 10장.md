# 발전하는 프레임워크

## 애플리케이션 수정 없이 프레임워크 수정하기
- 이상적인 프레임워크 업그레이드는 기능 추가를 하면서도 기존 기능이 변함없이 작동하게 해야한다.
- 프레임워크 개발에서는 기존 클라이언트 코드의 동작을 보장하면서 프레임워크를 발전시키기 위해 복잡도를 어느정도 높이는 것이 좀더 효율적인 경우가 많다.
- 프레임워크를 개발할 때는 복잡도를 낮출만한 발전의 여지를 남겨두면서 충분히 단순해서 당장 사용할 수 있어야한다.
- 적용범위를 확대할 여지를 남겨두면서도 당장 사용할 수 있을 정도의 적용성을 가져야한다.

## 호환성 없는 없그레이드
- 어떤 기능을 더이상 지원하지 않기로 하더라도 한두 번의 릴리즈에서 해당 기능을 계속 제공하게 되면, 그 기간 동안 클라이언트는 새로운 API로 옮겨갈 수 있다.
- 병렬 아키텍처는 복잡도를 높이지만 업그레이드로 인한 문제점을 줄여준다.
- 패키지를 사용하면 점진적으로 클라이언트 코드를 업그레이드할 수 있다.
- API와 구현을 바꾸되 한번에 둘 모두를 바꾸지 않는것이다.
- 호환성이 없는 업그레이드를 관리할 때 고려해야할 다른 요소는 클라이언트 커뮤니티의 구성과 성장세이다.


## 호환성을 유지하는 업그레이드
- 클라이언트 코드는 가급적 프레임워크의 세부 구현에 의존하지 않아야한다.
- 클라이언트는 프레임워크의 변화하지 않는 부분에만 의존적이여야 한다.

### 라이브러리 클래스
- 라이브러리 클래스를 사용하면 복잡도를 높이지 않으면서도 미래에 대비할 수 있다.
- 새로운 버전의 라이브러리 클래스를 릴리즈 하는 경우에도 기존 메소드가 이전과 같이 동작하는지만 확인하면 된다.
- API를 라이브러리 클래스로 표현하는 데 있어 큰 문제점은 표현할 수 있다는 개념과 변형의 수가 제한되어 있다는 것이다.

### 객체
- 프레임워크는 클라이언트에게 유용하고 안적적이면서 개발자에게는 발전시키기 쉬워야한다.
- 클라이언트가 프레임워크의 바뀌지 않을 것 같은 부분에만 의존적으로 코드를 작성하게 하는 것이다.

#### 사용스타일
- 클라이언트가 프레임워크 객체를 인스턴스화해서 사용할 것인가 아니면 확장시켜서 사용할 것인가.
- 인스턴트화
    - 클라이언트가 변경을 필요로 하지않고 데이터의 변경만을 필요로 하는경우 사용

- 설정
    - 클라이언트는 프레임워크 객체를 생성한 후 자신만의 객체를 프레임워크에 전달해서 프레임워크에서 사용되도록 한다 (bean?)
    - 데이터, 로직의 변경을 지원하므로 인스턴스보다 유연하다.
    - 설정을 사용해 클라이언트 객체를 호출하는 경우 계속해서 같은 인터페이스를 사용해야 하므로 프레임워크를 발전시키는데 제한이 생기고 코드에 대한 호환성을 보장해주기 어려워진다.
- 구현
    - 설정에서 제공하는 것 이상으로 많은 종류의 로직의 변경을 필요로하는 경우 사용
    - 호환성을 보장하기 위해 프레임워크에서 제공하는 상위 클래스나 인터페이스를 모두 그대로 유지해야한다.


#### 추상화
- 클래스 수준의 세부 사항을 인터페이스로 나타낼 것인가 클래스로 나타낼 것인가, 상태적으로 안정적인 세부 사항에 대해 어떤 가시성을 사용할 것인가
##### 인터페이스
- 세부사항을 가급적으로 적게 들어낸다는 이점이 있다.
- 인터페이스가 바뀌지 않는다면 괜찮지만, 새로운 메소드를 인터페이스에 추가하는 경우 기존인터페이스에 대한 모든 클라이언트 구현이 동작하지 않게 된다.
- 버전 인터페이스를 만들어 새로운 연산을 추가할 경우 기존 인터페이스가 필요한 경우에도 새로운 인터페이스를 사용할 수 있다.

##### 상위클래스
- 클래스는 인터페이스보다 세부사항을 나타낼 수 있으면서, 상위클래스에 새로운 메소드를 추가해도 호환성에 문제가 발생하지 않는다.
- 너무 많은 세부 사항을 공개한 경우 앞으로 설계 수정을 하는데 있어 많은 제약이 따른다.
    - 가급적이면 노출하는 세부 사항을 줄여서 인터페이스에 노출하는 정보 수준에 가깝게하라.
    - 프레임워크의 필드는 언제나 private여야 한다. 필드 접근을 해야한다면 취득 메소드를 제공하라.
    - final
        - final 키워드를 클래스에 사용하면 하위클래스를 생성할 수 없게 되어 인스턴스화나 설정 스타일중 한가지 방법으로 프레임워크를 사용해야만한다.
        - 메소드에 final 키워드를 사용하면 클라이언트에 노출된 메소드에 대해 언제나 어떤 메소드가 수행될지 보장해준다.
    - 내부 패키지
        - 프레임워크 세부 사항을 노출 하는 것과 감추는 것의 중간 단계를 제공
        - 클라이언트는 잠재적으로 불안정한 프레임워크의 일부를 사용할지 여부를 결정할 수 있다.

#### 생성
- 어떻게 객체를 생성하는가.
- 한가지 이상의 스타일을 사용하는 것도 가능하고 여러 부분에 각각 스타일을 적용하는 것도 가능하다. 

##### 생성 금지
- 프로그램이 너무나도 복잡해서 복자도를 족므이라도 줄이는 것이 바람직한 경우 클아이언트가 객체 생성을 하지 못하게 하는 것이 좋은 선택일 수 있다.
- 객체생성을 금지하는 경우 프레임워크의 가치를 더욱 높일 수 있는 기회를 잃을 수도 있따.

##### 생성자
- 장점
    - 생성자를 통해 객체를 생성하는 것의 장점은 클아이너트 입장에서 볼때 단순 명확하다는 것이다.
- 단점
    - 클라이언트가 생서자를 통해 객체를 생성하게 하는 것은 간단하지만 이 후 프레임워크 수정에 상당한 제약을 가져온다.
- 클래스의 패키지, 이름, 구상 클래스를 바꾸지 않아도 괜찮은 경우에 사용하는 것이 합리적이다.


##### 정적 공장
- 장점
    - 정적 공장을 사용하면 객체를 생성하는 복잡도가 상당히 증가하지만 프레임워크 개발자는 미래의 설계 수정에 유연성을 갖게된다.
    - 클라이언트 코드를 바꾸지 않고도 반환되는 객체의 패키지, 이름, 구상 클래스는 변경할 수 있다.
    - 객체 생성시의 변경을 클라이언트에게 좀더 명확히 전달할 수 있다는 점.
- 단점
    - 생성 괒어을 추상화할수록 코드를 읽으면서 어느 곳에서 객체가 생성되는지를 알기는 어려워진다.


##### 공장 객체
- 정적 메소드 호출 하는 대신 공장 객체에 메시지를 보내서 인스턴스를 생성하는 방법

- 장점
    - 함께 사용되는 클래스를 생성하는데 유용하게 사용할 수 있다.
- 단점
    - 공장 객체를 사용하면 정적 메소드보다 높은 유연성을 얻을 수 있지만, 코드를 읽기 어려워진다.
    - 어떤 클래스가 성생되는지 알기 위해서는 코드 수행을 따라가야 하기 때문이다.

- 공장 객체를 전역으로 사용한다면 정적 공장 메소드보다 나은 것이 없다.

#### 메소드
- 메소드를 어떻게 구성하면 클라이언트에게는 유용성을 프레임워크 개발자에게는 유연성을 제공할 수 있을까
- 프레임워크의 메소드를 만들 때 사용하는 기본 전략은 객체 생성 시의 전략과 크게 다르지 않다.
- 클라이언트가 사용할 수 있는 취득 메소드나 설정 메소드는 자료 구조를 수정하지 않는 경우에만 사용할 수 있다.
- 설정 메소드를 공개하는 것보다는 클라이언트가 해결하려는 문제를 메소드 이름에 반영하는 편이 좋다.
- 이미 공개된 메소드에 파라미터를 추가할 경우에는 호환성을 유지하기위해 기본 값을 제공하라.
