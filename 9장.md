# 컬렉션



#### 메타포 
- 컬렉션에는 여러 종류의 메타포가 녹아있다.
    - 변수
    - 객체

- 컬렉션은 인자로 전달 가능한 객체로 구현되므로 변수 값이 아닌 변수 자체를 인자로 전달하는 참조 호출의 효과를 얻을 수있다.
- 코드를 읽기 어려운것과 컬렉션이 수정되는 곳을 예측하기 어려운 상황을 피하기위해 몇가지 규범(Convention)이 있다.

#### 이슈
- 컬렉션을 사용할때는
    - 가급적 가장 일반적인 인터페이스를 사용해서 선언
    - 가장 구체적인 구현 클래스를 사용

- 컬렉션이 표현하는 개념
    1. 크기: 컬렉션은 중간에 크기를 수정할 수 있다.
    2. 원소간의 순서에 의미가 있는지 여부: 원소의 순서는 컬렉션에 추가된 순서가 될 수도 있고, 알파벳 순서와 같이 외부에서 정의한 순서가 될 수도 있다.
    3. 원소의 독자성
    4. 컬렉션의 선택은 성능에 관한 프로그래머의 의도를 전달해준다.

#### 인터페이스
- 인터페이스 선언은 컬렉션이 특정 순서대로 정렬되어 있는지 원소간의 중복을 허용하는지 키를 통한 원소 검색이 가능한지 등을 알려준다.

- 인터페이스 종류
    1. 배열
        - 배열은 가장 단순한 컬렉션 인터페이스
        - 매열의 크기는 배열 생성시 고정
        - 배열은 언어 자체에 포함되어 있음
        - 단순한 연산의 경우 다른 컬렉션에 비해 시간, 공간 모든면에서 효율적이다.

    2. Iterable
        - 기본적인 컬렉션 인터페이스로 순차열람을 지원
        - 원소를 추가하는 것은 막을 수 있지만 원소가 지워질 위험이 있다.

    3. Collection
        - Iterable을 상속하며, 원소 추가, 삭제, 검색, 크기 측정 등의 메소드를 추가로 지원한다.
        - 합집합, 교집합, 차집합과 같은 연산의 결과로 컬렉션 자체를 바꾸지는 대신 새로 할당된 컬렉션을 반환하라. (deepCopy)
        
    4. List
        - Collection을 기반으로 해서 원소 간에 정해진 순서를 부여
    
    5. Set
        - 중복 원소를 허용하지 앟는 컬렉션
        - Set의 원소 사이에는 순서가 없다.

    6. SortedSet
        - 순서는 유지되지만 중복 원소가 없는 컬렉션 
        - List와는 달리 SortedSet은 Comparator에 의해 순서를 저장한다.

    7. Map 
        - 다른 인터페이스를 혼합한 형태
        - 내부적으로 키에 대한 컬레션과 데이터에 대한 컬렉션의 2개 컬렉션을 유지한다.
        - Map에 대해서는 단순히 순차 열람자를 요청할 수 없다.


#### 구현
- 컬렉션에 대해 구현 클래스를 선택하는 것은 주로 성능과 관련 되어있다.
- 일단 단순한 구현으로 시작한 수 경험에 다라 튜닝을 하는 것이 좋다.
    - ArrayList, HashSet 중 적합한 것을 고르는 것도 괜찮다.
- 컬렉션의 크기에 따라 구현을 선택

- Collection
    - Collection 인터페이스에 대한 기본 구현 클래스는 ArrayList이다.
    - ArrayList는 컬렉션의 크기에 비례해서 연산이 커지는 contains(Object)가 있다.
    - 이러한 메소드들이 성능을 제약한다면 HashSet으로 바꾸는 것을 고려해보자.

- List
    - 흔히 사용하는 List에 대한 구현은 ArrayList, LinkedList이다.
    - ArrayList는 원소 접근이 빠르고 원소 추가 및 제거가 느린데 반해.
    - LinkedList는 원소 접근이 느리지만 원소 추가와 제거는 빠르다.
    
- Set
    - 많이 사용하는 Set 인터페이스의 구현에는 HashSet, LinkedHashSet, TreeSet 세가지가 있다.
    - HashSet은 가장 빠르지만 원소간의 순서를 보장해주지 않는다.
    - LinkedHashSet은 원소간 순서를 삽입된 순서로 보장해주지만 원소 추가 삭제시 30% 정도 시간이 더 걸린다. 
    - TreeSet은 Comparator에 따라서 원소를 정렬하지만 원소 추가 삭제 시간이 logn에 비례해서 커진다.
- Map
    - HashMap은 가장 빠르고 단순하다.
    - LinkedHashMap은 컬렉션에 추가된 원소 간 순서를 보장한다.
    - TreeMap은 키의 순서에 따라서 순차 열람이 가능하지만 원소 추가 시간이 logn에 비례한다.

#### Collections
- Collections는 다른 컬렉션 인터페이스에 넣기 적절치 않은 기능들을 모아놓은 유틸리티 클래스이다.
- 검색
    - indexOf() 연산에 걸리는 시간은 리스트 크기에 비례한다.
    - 원소들이 정렬되어 있다면 이진검색을 사용해서 nlog2n에 비례하는 시간에 검색할 수 있다.
        - Collections.binarySearch(list, element)를 사용하면 좀더 효율적으로 리스트 원소에 대한 인덱스를 구할 수 있다.
        - 원소가 리스트에 존재하지 않으면 음수를 반환한다.
        - 리스트가 저렬되어 있지 않다면 결과는 예측할 수 없다.

- 정렬
    - 리스트 원소 간의 순서를 바꾸는 연산을 제공한다.
    - reverse(list): 리스트의 속해 있는 모든 원소간의 순서를 거꾸로 바꾼다.
    - shuffle(list): 순서를 임의로 바꾼다.
    - sort(list), sort(list, comparator): 오름 차순으로 원소를 정렬한다.

- 수정 불가능한 컬렉션
- 단일 원소 컬렉션
- 무원소 컬렉션


#### 컬렉션 확장
