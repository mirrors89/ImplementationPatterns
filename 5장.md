# 클래스

- 클래스는 잠재적으로 여러 세부 사항을 내포할 수 있으므로, 클래스의 사용은 커뮤니케이션을 위한 프로그램에 있어 매우 중요하다.
- 널리 알려져 있는 디자인 패턴은 클래스 간의 관계를 다루는 것이다.


### 클래스

> 클래스의 로직과 데이터는 함께 사용되며, 로직은 데이터에 비해 변화율이 낮다. 클래스 내부의 데이터는 관련 로직에 의해 변화하며 클래스 내부에서 사용하는 데이터의 변화율은 비슷하다.

- 클래스 계층을 구성하는 것은 일종의 압축 기법을 사용하는 것
- 클래스 계층을 사용하면 코드를 읽기 어려워진다. 
- 하위 클래스를 이해하기 위해서는 상위 클래스도 이해해야하기 때문.
- 클래스는 객체 지향 프로그램의 설계 요소중 비교작 값이 비싼 편이므로 뭔가 의미 있는 작업에만 클래스를 사용해야한다.


### 단순한 상위클래스 이름

- 적합한 이름은 여러모로 코드를 단순화하고 향상 시켜준다.
- 중요한 클래스에 대해서는 한 단어로 된 이름을 사용하는 것이 좋다.


### 한정적 하위클래스 이름

- 하위클래스의 이름은 상위 클래스와의 유사점과 차이점을 나타내야한다.
- 어느정도 간결성은 포기하더라도, 표현성을 택하는 편이 낫다.
- 상위클래스 이름에 한두 개의 수식어를 붙여서 하위클래스 이름을 정하는 경우가 많다.
- 클래스의 이름은 코드의 내용을 반영해야 한다.


### 추상 인터페이스

- 구현이 아니라 인터페이스에 맞춰 코딩하라는 말이 있다.
- 인터페이스란 `구현이 빠진 여러 연산의 집합`을 의미한다.
- 인터페이스를 통해 유연성을 얻을 수 있는 경우에만 인터페이스에 비용을 지불해야한다.
- 인터페이스를 사용하게 된 경제적 이유로는 소프트웨어는 예측하기 어렵다는 점을 들 수 있다.


### 인터페이스

- 인터페이스는 다중 상속의 유연성을 제공하면서도 복잡성과 모호성을 갖고 있지 않은 적절하게 균형이 잡힌 메커니즘이다.
- 인터페이스를 바꾸거나 추가하면 인터페이스를 구현하는 모든 클래스를 수정 해야한다.
- 모든 구현을 바꾸는 것이 쉽지 않은 경우라면 전체 설계를 개선하기는 어렵다.
- 인터페이스의 이름을 짓는 방법
    - 인터페이스를 구현이 빠져있는 클래스(추상 클래스)로 간주하는 경우 클래스와 같은 방법을 사용해 이름을 지으면 된다. 
    - 구상 클래스의 이름을 간결하게 짓는 것이 인터페이스 사용을 숨기는 것보다 코드 커뮤니케이션에 있어 중요한 경우 인터페이스 이름 앞에에 I를 붙여서 사용하면 된다. 


### 추상 클래스

- 추상 클래스는 기본 구현을 사용할 수 있는 길이 열려 있는한, 기존 설계를 망가 뜨리지 않고 새로운 연산을 얼마든지 추가할 수 있다.
- 클래스가 단 1개의 상위클래스만을 지정할 수 있다는 단점이 있다.
- 자바 클래스에서 `abstract` 키워드를 씀으로써, 해당 클래스를 사용하기 우ㅏ해서는 반드시 구현이 필요하다는 사실을 코드 독자에게 전달할 수 있다.


### 버전 인터페이스

- 인터페이스에 연산을 추가하면 기존 인터페이스를 구현한 클래스가 동작 하지 않게 되므로 함부로 연산을 추가하기 어렵다.
- 그러나 새로운 인터페이스를 상혹한 후 새로운 연산을 추가할 수는 있다.
- 새로 확장한 대체 인터페이스의 수가 많아지면 클라이언트가 할 일이 크게 늘어난다.


### 값 객체

- 값 스타일 객체를 사용할 때의 문제점은 성능이지만, 전체 성능의 병목지점이라 볼 수 없으므로 이 주장은 큰 설득력이 없다.
- 값 스타일의 객체에서는 생성자에서만 모든 상태를 설정할 뿐, 다른 경로를 통해서는 필드 값을 변경하면 안된다.
- 값 스타일의 객체를 다루는 연산은 언제나 새로운 객체를 반환한다.


### 특화
- 가장 간단한 변형은 상태만 바꾸는 것이다.
- 가장 복잡한 변형은 로직 자체를 완전히 바꾸는 것이다.
- 데이터의 변형은 그리 복잡하거나 미묘하지 않다
- 로직에서 유사점과 차이점을 효과적으로 표현하면, 추후 코드 확장성이 한결 좋아진다.


### 하위 클래스

- 적당한 메소드를 오버라이드 할 경우 간단한 코드 몇줄이면 기존 연산과 다른 변형을 만들어 낼 수 있다.
- 문제점
    - 하위클래스를 사용하면 되돌리기 쉽지않다.
    - 하위클래스를 이해하기 위해서는 상위 클래스를 이해해야한다.
    - 하위클래스가 상위 클래스 세부 구현 특성에 의존할 수 있으므로 상위클래스의 수정이 위험해진다.
    - 상속을 사용할 때 치명적인 문제는 병렬 클래스 계층을 이용하는 경우.
- 하위 클래스를 올바르게 사용하기 위해서는 상위 클래스의 로직을 어려개의 메소드로 잘게 쪼개는 것이다.


### 구현자

- 객체 지향적 프로그램에서는 선택을 표현하기 위해 주로 다형적 메시지를 사용한다.
- 다형적 메시지는 여러 가지 변경을 수용할 수 있다.
- 명시적이고 폐쇄적인 조건문을 사용하는 프로지서 표현에 비해 객체와 메시지를 사용하는 방식은 좀더 명확히 프로그래머의 의도를 나타낸다.
- 프로시저에 기반해서 자바 프로그램을 작성하는 경우 풍부한 객체지향 언어의 자원들을 제대로 사용할 수 없다.


### 내부 클래스

- 클래스 사용에 따른 비용을 지불하지 않으면서도 클래스의 장점을 대부분 취할 수 있다.
- 내부 클래스는 내부클래스를 감싼 클래스에 대한 정보를 암묵적으로 전달받는다. 
- 클래스간의 관계를 명시적으로 정하지 않으면서도 감싼 클래스의 데이터를 접글할 수 있는 유용한 기법이다.


### 인스턴스별 행동

- 인스턴스별로 다른 행동을 보이는 경우 특정 인스턴스의 행동을 이해하기 위해서는 실례를 보거나 데이터의 흐름을 분석해야만 한다.
- 연산 수행 도중에 로직이 변화하는 경우 인스턴스별 행동에 따른 비용은 더욱 커진다.
- 코드를 쉽게이해하기 위해서는 인스턴스 생성 후에는 인스턴스별 행동을 변화하지 않는 편이 좋다.


### 조건문

- 수행 경로가 다양한 프로그램이 결함을 갖고 있을 확률이 높다. 조건문의 수가 많으면 프로그램의 안정성이 떨어지는 경향이 있다.
- 새로운 조건이 필요할 경우 모든 조건문에 새로운 절을 삽입해야 한다.
- 조건문은 단순성과 지역성에서 장점이 있지만 광범위하게 사용되는 경우 이러한 장점이 문제가 될 수도 있다.
- 하위 클래스나 위임중 적절한 방법을 통해 조건문을 메시지로 바꾸면 해결할 수 있다.


### 위임

- 인스턴스에서 다른 로직을 수행하도록 하는 방법 중에 하나
- 변형은 여러 객체에서 각각 구현된다.
- 위임은 인스턴스별 행동을 지원할 뿐만 아니라, 코드 공유에도 사용할 수 있다.
- 위임을 좀더 응용해서, 위임자 클래스(delegator)를 위임 메소드(delegated method)에 인자로 넘겨주는 방식으로 사용하기도 한다.
- 위임을 사용해서 자기 자신에게 메시지를 보낸다면, “자기 자신”이 무엇인지 분명치 않다.


### 플러그인 선택자

- 한두 개의 메소드에서만 인스턴스별 행동이 필요하며, 모든 로직이 하나의 클래스 안에 들어가도 좋은 경우
- 이런 경우엔 메소드 이름을 필드에 저장해 두고 리플렉션을 통해 메소드를 호출하는 것도 좋다.
- 플러그인 선택자의 비용은 상당하므로, 비용을 정당화할 수 있는 곳에 제한적으로 사용해야 한다.


### 익명 내부 클래스

- 한 곳에서만 사용되는 클래스를 생성해서 일부 메소드를 오버라이드한 후, 지역적으로만 사용 하는 것이다.
- 익명 클래스를 효율적으로 사용하려면 API가 매우 간단하거나 상위 클래스가 대부분의 구현을  담당하고 있어서 내부클래스를 쉽게 구현할 수 있어야 한다.
- 클래스 이름을 사용할 수 없으므로 클래스 이름을 통해 프로그래머의 의도를 전달할 수 없다.


### 라이브러리 클래스

- 인스턴스화가 불가능한 라이브러리 메소드만을 가지고 있는 클래스다.
- 모든 로직을 정적 메소드로 구현하면, 객체 지향 프로그래밍의 가장 큰장점 - 공유데이터를 전용 네임 스페이스를 사용하여 표현을 해서  로직을 단순화 하는 것을 잃게된다.
- 그래서 가능한 경우 라이브러리 클래스는 객체로 변환하는 것이 좋다.
